package framework.utilities.helper_package;

import static framework.utilities.customWebUI.WebUI.*;

import java.awt.image.BufferedImage;
import java.io.File;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;

import javax.imageio.ImageIO;

import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.log4j.Logger;
import org.openqa.selenium.By;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;

import product.actionbot.ActionBot;
import product.constants.iConstants;
import bsh.ParseException;
import framework.frameworkUtilies.GlobalVariable;
import framework.utilities.customWebUI.WebUI;

public class commonUtilities
{

	public static Logger logger = Logger.getLogger("commonUtilities");

	/**
	 * ;
	 * 
	 * @description: uniqueRequisitionName generates unique number and
	 *               Concatenate with fixed string variable;
	 * @param: Nil;
	 * @return: unique requisition name;
	 */

	public static String uniqueRequisitionName()
	{
		// String reqname= "Automation_"+ System.currentTimeMillis();
		String reqname = "" + System.currentTimeMillis();
		reqname = "Auto_" + reqname.substring(6, 12);

		return reqname;
	}

	/**
	 * ;
	 * 
	 * @description: uniqueGuidedItemReqName generates unique number and
	 *               Concatenate with fixed string variable;
	 * @param: Nil;
	 * @return: unique requisition name;
	 */

	public static String uniqueGuidedItemReqName()
	{
		String reqname = "GuidedItemRequisition_" + System.currentTimeMillis();
		return reqname;
	}

	/**
	 * ;
	 * 
	 * @description: autoGeneratedComment generates comments of fixed length;
	 * @param: Nil;
	 * @return: string of comment;
	 */

	public static String autoGeneratedComment()
	{
		String comment = "This is auto generated comment ";
		String autoGenComment = "";
		for (int i = 0; i < 2; i++)
		{
			autoGenComment = autoGenComment + "-" + comment;
		}
		return autoGenComment;
	}

	/**
	 * ;
	 * 
	 * @description: randomNumberBetweenRange generates random number between
	 *               given Min and Max range;
	 * @param: Min
	 *             & Max range;
	 * @return: random number in string format;
	 */

	public static String randomNumberBetweenRange(int min, int max)
	{
		int number = ThreadLocalRandom.current().nextInt(min, max);
		return number + "";
	}

	/**
	 * ;
	 * 
	 * @description: randomStringWithSymbols generates alphanumeric random
	 *               string of given length with symbols;
	 * @param: length
	 *             of string;
	 * @return: random string with symbols;
	 */

	public static String randomStringWithSymbols(int length)
	{
		String characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789~`!@#$%^&*()-_=+[{]}\\|;:\'\",<.>/?";
		String rndmString = RandomStringUtils.random(length, characters);
		return rndmString;
	}

	/**
	 * ;
	 * 
	 * @description: randomScript generates random script of given length;
	 * @param: length
	 *             of script message;
	 * @return: random script with symbols;
	 */

	public static String randomScript(int length)
	{
		String rndmScript = "<script>alert(\"" + commonUtilities.randomStringWithSymbols(length) + "\")</script>";
		return rndmScript;
	}

	/**
	 * ;
	 * 
	 * @description: getTodayDay returns current day;
	 * @param: Nil;
	 * @return: current day;
	 */

	public static String getTodayDay()
	{

		Calendar today = Calendar.getInstance();
		today.get(Calendar.DATE);
		today.get(Calendar.MONTH);
		today.get(Calendar.YEAR);
		// String date =today.get(Calendar.DATE) + "/" +
		// (today.get(Calendar.MONTH) + 1) + "/" + today.get(Calendar.YEAR);
		return String.valueOf(today.get(Calendar.DATE));
	}

	/**
	 * ;
	 * 
	 * @description: getTodayDay returns current day;
	 * @param: Nil;
	 * @return: current day;
	 */

	public static ArrayList<Integer> splitNumberBasedOnRange(int range, int max)
	{
		ArrayList<Integer> allNumber = new ArrayList<Integer>();
		int maxValue = max;
		int averageNo = maxValue / range;
		int difference = max - (averageNo * range);
		int firstNo = averageNo + difference;
		allNumber.add(firstNo);
		for (int i = 1; i < range; i++)
		{
			allNumber.add(averageNo);
		}
		return allNumber;
	}

	/**
	 * ;
	 * 
	 * @description: splitDoubleNumberBasedOnRange splits given number in given
	 *               no of split count;
	 * @param: splitCount(Number
	 *             of splits) & amount(number which we have to split);
	 * @return: list of number;
	 */

	public static ArrayList<Double> splitDoubleNumberBasedOnRange(int splitCount, String amount)
	{
		ArrayList<Double> allNumber = new ArrayList<Double>();

		String getMaxValue;
		String[] splitMaxValue;
		getMaxValue = amount;
		getMaxValue = getMaxValue.replace(",", "");
		splitMaxValue = getMaxValue.split("\\.");
		int maxValue = Integer.parseInt(splitMaxValue[0]);
		int averageNo = maxValue / splitCount;
		int difference = maxValue - (averageNo * splitCount);
		String floatNo = "00." + splitMaxValue[1];
		double firstNo = averageNo + Double.parseDouble(floatNo) + difference;
		allNumber.add(firstNo);
		for (int i = 1; i < splitCount; i++)
		{
			allNumber.add((double) averageNo);
		}

		return allNumber;
	}

	/**
	 * ;
	 * 
	 * @description: splitPercentageBasedOnRange splits 100% in given no of
	 *               split count;
	 * @param: splitCount(Number
	 *             of splits);
	 * @return: list of number;
	 */

	public static ArrayList<Integer> splitPercentageBasedOnRange(int splitCount)
	{
		int randNo = Integer.parseInt(commonUtilities.randomNumberBetweenRange(1, 70));
		ArrayList<Integer> allNumber = new ArrayList<Integer>();
		int maxValue = 100;
		int firstNo = randNo;
		int secondNo = maxValue - randNo;
		allNumber.add(firstNo);
		splitCount = splitCount - 1;
		int averageNo = secondNo / splitCount;
		int difference = secondNo - (averageNo * splitCount);
		secondNo = averageNo + difference;
		allNumber.add(secondNo);

		for (int i = 1; i < splitCount; i++)
		{
			allNumber.add(averageNo);
		}
		return allNumber;
	}

	public static String uniqueGuidedItemName()
	{
		String reqname = "GuidedItem_" + System.currentTimeMillis();
		return reqname;
	}

	public static Integer getNonZeroRandomNumbers(int size)
	{
		Integer number = 0;
		while (number == 0 || number == 1)
		{
			number = Integer.parseInt(RandomStringUtils.randomNumeric(size));
		}
		return number;
	}

	public static void uploadImage(WebDriver driver, String imagePath, String testcaseName) throws Exception
	{

		try
		{
			logger.info("imagePath : " + imagePath);
			WebUI.waitForElementVisible(driver,findTestObject(driver,iConstants.IMAGE_UPLOAD_BUTTON), GlobalVariable.DEFAULT_MEDIUM_WAIT);
			WebUI.delay(10);
			ActionBot.click(driver, iConstants.IMAGE_DELETE_BUTTON);
			// if(getHeight(imagePath)<=200 && getWidth(imagePath)<=200);
			// {

			WebElement element = driver.findElement(By.xpath("//input[@id='ImageUploadFile']"));
			JavascriptExecutor jsexec = (JavascriptExecutor) driver;
			String attributeClass = element.getAttribute("class");
			if (attributeClass.contains("hidden"))
			{
				String value = "hidden";
				attributeClass = StringUtils.remove(attributeClass, value);
				jsexec.executeScript("arguments[0].setAttribute('class',arguments[1])", element, attributeClass);
				// WebUI.scrollToElement(driver,findTestObject(driver,"FlowOR/Requisition/GuidedItem/Add
				// Non Stock Item Details/UploadImage"), imagePath);
				element.sendKeys(imagePath);
				ActionBot.defaultSleep();
			}
			// }

			// else;
			// {
			// logger.info("Invalid image size");
			// }
		}
		catch (Exception e)
		{

			logger.error("Exception occured in Image upload ");
			throw e;
		}
	}

	public static int getHeight(String filePath)
	{
		File file = null;
		BufferedImage img = null;
		int height = 0;
		try
		{
			file = new File(filePath);
			img = ImageIO.read(file);

			height = img.getHeight();

			logger.info("Height: " + height);

		}

		catch (Exception e)
		{
			logger.error("Image not found" + e);
		}
		return height;

	}

	public static int getWidth(String filePath)
	{
		File file = null;
		BufferedImage img = null;
		int width = 0;

		try
		{
			file = new File(filePath);
			img = ImageIO.read(file);

			width = img.getWidth();

			logger.info("Width: " + width);

		}

		catch (Exception e)
		{
			logger.error("Image not found" + e);
		}
		return width;

	}

	/**
	 * ;
	 * 
	 * @description: getRandomNumberWithinLimit generates random number between
	 *               given Min and Max range;
	 * @param: Min
	 *             & Max range;
	 * @return: random number in int format;
	 */

	public static int getRandomNumberWithinLimit(int min, int max) throws Exception
	{
		int num = 0;
		try
		{
			Random random = new Random();
			num = random.nextInt((max - min) + 1) + min;
			logger.info("Generated Random Number is : " + num);
		}
		catch (Exception e)
		{
			logger.error("Exception in Random Number Generation.");
			throw e;
		}
		return num;
	}

	/**
	 * ;
	 * 
	 * @description: fetches cart item count specified between '(" & ")'.;
	 * @param: Cart
	 *             page title;
	 * @return: cart item count;
	 */
	public static int fetchCartCount(String value) throws Exception
	{
		int itemCount = 0;
		try
		{
			String count = StringUtils.substringBetween(value, "(", ")");
			itemCount = Integer.parseInt(count);
		}
		catch (Exception e)
		{
			logger.error("Error while fetching auto generated Unique Code.");
			throw e;
		}

		return itemCount;
	}

	/**
	 * ;
	 * 
	 * @description: Clear specified directory;
	 * @param: File
	 *             instance; ;
	 */

	public static boolean clearFolder(String filepath) throws Exception
	{
		boolean isDirectoryEmpty = false;
		try
		{
			File directory = new File(filepath);
			if (directory.exists())
			{
				File[] files = directory.listFiles();
				if ((files.length == 0))
				{
					isDirectoryEmpty = true;
					logger.info("Folder '" + directory.getName() + "' is already empty.");
				}
				else
				{
					for (File file : files)
					{
						if (file.isDirectory())
						{
							logger.info("Folder '" + file.getName() + "' is present. Deleting it...");
							file.delete();
						}
						else
						{
							logger.info("File '" + file.getName() + "' is present. Deleting it...");
							file.delete();
						}
					}

					files = directory.listFiles();
					if (files == null)
					{
						isDirectoryEmpty = true;
						logger.info("Folder '" + directory.getName() + "' is empty.");
					}
				}
			}
			else
			{
				logger.info("Folder '" + directory.getName() + "' doesn't exist...!");
			}
		}
		catch (Exception e)
		{
			throw e;
		}

		return isDirectoryEmpty;
	}

	public static String fetchWebLink(List<String> attachments) throws Exception
	{
		String webLink = null;
		try
		{
			for (String attachment : attachments)
			{
				// String ext = FilenameUtils.getExtension(attachment);
				if (attachment.contains("https://") || attachment.contains("http://"))
				{
					webLink = attachment;
					logger.info("Web link is present.");
					break;
				}
			}

			if (webLink == null)
			{
				logger.info("Web link is not present.");
			}
		}
		catch (Exception e)
		{
			throw e;
		}

		return webLink;
	}

	public static boolean scrollBarPresent(WebDriver driver) throws Exception
	{
		boolean status = false;

		try
		{
			/*
			 * String JS_ELEMENT_IS_SCROLLABLE =
			 * "return arguments[0].scrollHeight > arguments[0].offsetHeight;";
			 * JavascriptExecutor jse = (JavascriptExecutor)driver; WebElement
			 * container =
			 * driver.findElement(By.cssSelector(".checkout-mini-cart"));
			 * Boolean isScrollable =
			 * (Boolean)jse.executeScript(JS_ELEMENT_IS_SCROLLABLE, container);
			 */

			String execScript = "return document.documentElement.scrollHeight>document.documentElement.clientHeight;";
			JavascriptExecutor scrollBarPresent = (JavascriptExecutor) driver;
			Boolean test = (Boolean) (scrollBarPresent.executeScript(execScript));

			if (test == true)
			{
				status = true;
				System.out.print("Scrollbar is present.");
			}
			else if (test == false)
			{
				status = false;
				System.out.print("Scrollbar is not present.");
			}
		}
		catch (Exception e)
		{
			throw e;
		}

		return status;
	}

	public static String currentdateTime(String format)
	{
		String dateTime = null;
		DateFormat dateFormat = new SimpleDateFormat(format);
		Date date = new Date();
		dateTime = dateFormat.format(date);

		return dateTime;
	}

	public static String dateFormat(String date, String pattern) throws Exception
	{
		try
		{
			String formattedDate = null;
			String[] ddMMyyyy = date.split("/");
			LocalDate date2 = LocalDate.of(Integer.parseInt(ddMMyyyy[2]), Integer.parseInt(ddMMyyyy[1]), Integer.parseInt(ddMMyyyy[0]));
			DateTimeFormatter dtd = DateTimeFormatter.ofPattern(pattern);
			return formattedDate = dtd.format(date2);
		}
		catch (Exception e)
		{
			throw e;

		}

	}

	public static String futureDate(String format, int futureDays) throws Exception
	{
		String finalDate = null;
		try
		{
			DateFormat dateFormat = new SimpleDateFormat(format);
			Date date = new Date();
			Calendar calendar = Calendar.getInstance();
			calendar.setTime(date);
			calendar.add(Calendar.DAY_OF_YEAR, futureDays);
			finalDate = dateFormat.format(calendar.getTime());
		}
		catch (Exception e)
		{
			throw e;
		}
		return finalDate;
	}

	public static String getSubmitReqConfirmationMsg(String reqName, String totalPrice, int itemCount)
	{
		String reqMessage = null;

		String[] price = StringUtils.split(totalPrice, " ");
		if (price[1].equals("0.00"))
		{
			reqMessage = "You are about to submit the requisition " + reqName + " amounting " + totalPrice + " with " + itemCount + " item(s) and this requisition also includes zero-price items.";
		}
		else
		{
			reqMessage = "You are about to submit the requisition " + reqName + " amounting " + totalPrice + " with " + itemCount + " item(s).";
		}

		return reqMessage;
	}

	/**
	 * ;
	 * 
	 * @description: Check if attachment is downloaded in specified folder;
	 * @param:downloaded attachment
	 *                       name to check in folder;
	 * @return: true if downloaded attachment is present in folder;
	 */

	public static boolean checkIfdownloadedAttachmentPresent(String attachmentName) throws Exception
	{
		boolean flag = false;

		try
		{
			File dir = new File(System.getProperty("user.home") + GlobalVariable.FILE_DOWNLOAD_PATH);
			File[] dir_contents = dir.listFiles();

			for (int i = 0; i < dir_contents.length; i++)
			{
				String name = dir_contents[i].getName();
				if (name.equals(attachmentName))
				{
					flag = true;
					if (dir_contents[i].delete())
					{
						logger.info("File '" + dir_contents[i].getName() + "' has been deleted.");
					}
				}
			}
		}
		catch (Exception e)
		{
			throw e;
		}

		return flag;
	}

	public static File createDownloadFolder() throws Exception
	{
		File file = new File(GlobalVariable.FILE_DOWNLOAD_PATH);
		boolean dirTest = file.mkdir();
		if (file.exists())
		{
			logger.info("Folder '" + file.getName() + "' is created.");
		}
		else
		{
			logger.error("Folder is not created.");
		}

		return file;
	}

	public static List<String> fetchFilesFromFolder(String folderPath) throws Exception
	{
		List<String> folderFiles = new ArrayList<String>();
		try
		{
			File dir = new File(folderPath);
			File[] files = dir.listFiles();
			if (files.length > 0)
			{
				for (File file : files)
				{
					if (!file.isDirectory())
					{
						folderFiles.add(file.getPath());
					}
				}

				logger.info("Total files are : " + folderFiles.size());
			}
		}
		catch (Exception e)
		{
			throw e;
		}

		return folderFiles;
	}

	public static double countFileSizeMB(String filePath) throws Exception
	{
		File file = new File(filePath);
		double size = file.length() / (1024 * 1024);
		String fileSizeMB = String.valueOf(size).concat(" MB");
		logger.info("File '" + file.getName() + "' is '" + size + ".");
		return size;
	}

	public static boolean isValidDateFormat(String format, String value)
	{
		LocalDateTime ldt = null;
		DateTimeFormatter fomatter = DateTimeFormatter.ofPattern(format, Locale.ENGLISH);

		try
		{
			ldt = LocalDateTime.parse(value, fomatter);
			String result = ldt.format(fomatter);
			return result.equals(value);
		}
		catch (DateTimeParseException e)
		{
			try
			{
				LocalDate ld = LocalDate.parse(value, fomatter);
				String result = ld.format(fomatter);
				return result.equals(value);
			}
			catch (DateTimeParseException exp)
			{
				try
				{
					LocalTime lt = LocalTime.parse(value, fomatter);
					String result = lt.format(fomatter);
					return result.equals(value);
				}
				catch (DateTimeParseException e2)
				{
					// Debugging purposes;
					// e2.printStackTrace();
				}
			}
		}

		return false;
	}

	public static String uniqueAssetNumber()
	{
		String assetNumber = "AssetNumber_" + System.currentTimeMillis();
		return assetNumber;
	}

	public static String manufacturerNumber()
	{
		String number = "Manufacturer_No_" + System.currentTimeMillis();
		return number;
	}

	public static float randomFloatNumberBetweenRange(int min, int max) throws Exception
	{
		Random random = new Random();
		float f = min + (random.nextFloat() * (max - min));
		return f;
	}

	public static long getRandomNumberOfSize(int size) throws Exception
	{
		Integer number = 0;
		while (number == 0 || number == 1)
		{
			number = Integer.parseInt(RandomStringUtils.randomNumeric(size));
		}
		return number;
	}

	public static String uniqueBasketName()
	{
		String basketName = "AutomationBasket_" + System.currentTimeMillis();
		return basketName;
	}

	public static String convertDateFormat(String dateString, String actualFormat, String requiredFormate) throws java.text.ParseException
	{
		String finaldate = null;
		logger.info("Given date is " + dateString);

		DateFormat sdf = new SimpleDateFormat(actualFormat);
		Date date = sdf.parse(dateString);
		finaldate = new SimpleDateFormat(requiredFormate).format(date);
		logger.info(requiredFormate + " formatted date : " + finaldate);

		return finaldate;
	}

	public static String returnFormattedDate(String date, String pattern) throws Exception
	{
		try
		{
			String formattedDate = null;
			SimpleDateFormat formatter = new SimpleDateFormat(pattern);
			@SuppressWarnings("deprecation")
			String strDate = formatter.format(new Date(date));
			logger.info(strDate);
			return strDate;
		}
		catch (Exception e)
		{
			throw e;

		}
	}

	public static int getDayOftheMonth(int futureDays) throws Exception
	{
		int finalDay = 0;
		try
		{
			Date date = new Date();
			Calendar calendar = Calendar.getInstance();
			calendar.setTime(date);
			calendar.add(Calendar.DAY_OF_YEAR, futureDays);
			finalDay = calendar.get(Calendar.DAY_OF_MONTH);
		}
		catch (Exception e)
		{
			throw e;
		}
		return finalDay;
	}

}
